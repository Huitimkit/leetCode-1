<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Min Stack</title>
</head>
<body>
	<script>
		/*
			Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

			push(x) -- Push element x onto stack.
			pop() -- Removes the element on top of the stack.
			top() -- Get the top element.
			getMin() -- Retrieve the minimum element in the stack.
		*/
		/**
		 * initialize your data structure here.
		 */
		var MinStack = function() {
		    this.dataStore = [];
		    this.index = 0;
		};

		/** 
		 * @param {number} x
		 * @return {void}
		 */
		MinStack.prototype.push = function(x) {
		    this.dataStore[++this.index] = x;
		};

		/**
		 * @return {void}
		 */
		MinStack.prototype.pop = function() {
		    if(this.index > 0){
		        return this.dataStore[--this.index];   
		    }
		};

		/**
		 * @return {number}
		 */
		MinStack.prototype.top = function() {
		    if(this.dataStore.length){
		        return this.dataStore[this.index];   
		    }
		};

		/**
		 * @return {number}
		 */
		MinStack.prototype.getMin = function() {
			//正常思路这个也应该用栈来实现，但是这里本身就是模拟栈，所以直接循环得到结果
		    var min = Number.MAX_VALUE,
		        len = this.dataStore.length;
		    if(len){
		        for(var i = 0; i <= this.index; i++){
		            var num = this.dataStore[i];
		            if(typeof num === 'number' && num < min){
		                min = num;
		            }
		        }
		    }
		    return min === Number.MAX_VALUE ? null: min;
		};
	</script>
</body>
</html>